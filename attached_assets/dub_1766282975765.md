# Implementing Dub.co URL shortener with analytics in Replit Agent 3

Dub.co provides a modern link management platform with robust analytics that integrates seamlessly with Replit deployments. For AI consulting tools generating shareable HTML reports, this integration enables professional shortened URLs like `go.yourdomain.com/report-abc` with full click tracking, geographic data, and conversion attribution—all accessible through a clean TypeScript SDK or REST API.

## Setup and account configuration

### Creating your Dub.co account and API key

Start by registering at `https://app.dub.co/register` and creating a workspace. Once logged in, generate an API key by navigating to **Settings → API Keys** and clicking "Create." Select **All permissions** for full access (or **Restricted** for granular control over Links, Analytics, Domains, and Tags). Choose **Machine** association type for integrations—this creates a dedicated machine user rather than tying the key to your personal account. Copy the key immediately; it won't display again.

Your API key follows the format `dub_xxxxxxxx` and authenticates all requests via Bearer token.

### Configuring Replit Secrets for API keys

In Replit, open the **Secrets** panel (Tools → Secrets in the left dock, or search "Secrets"). Add these secrets:

| Secret Name | Value | Purpose |
|-------------|-------|---------|
| `DUB_API_KEY` | `dub_xxxxxx` | Primary API authentication |
| `DUB_WEBHOOK_SECRET` | Your webhook signing secret | Webhook signature verification |

Access secrets in Node.js via `process.env.DUB_API_KEY`. Replit encrypts secrets with AES-256 at rest and TLS in transit. Secrets automatically copy to production when you deploy.

### Custom domain setup (optional but recommended)

For professional report URLs, configure a custom domain like `go.yourcompany.com`. In Dub's dashboard, navigate to **Domains** and click "Add Domain."

**For subdomains** (recommended: `go.`, `link.`, or `try.`), add a CNAME record:
```
Name: go
Type: CNAME
Value: cname.dub.co
TTL: 86400
```

**For apex domains**, add an A record pointing to `76.76.21.21`. Dub handles SSL certificates automatically. DNS propagation takes **1-24 hours**—Cloudflare users should set DNS to "DNS only" mode to ensure accurate analytics.

## Core API integration

### Installing the TypeScript SDK

The official `dub` package provides type-safe methods for all API operations:

```bash
npm install dub
```

Initialize the client in your application:

```typescript
import { Dub } from "dub";

const dub = new Dub({
  token: process.env.DUB_API_KEY // Defaults to DUB_API_KEY env var if omitted
});
```

### REST API structure

All requests target `https://api.dub.co` with Bearer authentication:

```bash
curl -X POST https://api.dub.co/links \
  -H "Authorization: Bearer dub_xxxxxx" \
  -H "Content-Type: application/json" \
  -d '{"url": "https://example.com"}'
```

Key endpoints include `POST /links` (create), `GET /links` (list), `GET /links/{linkId}` (retrieve), `PATCH /links/{linkId}` (update), `DELETE /links/{linkId}` (delete), and `POST /links/bulk` for batch operations.

## Building a reusable Dub.co service module

Create a comprehensive service module that handles all link operations with proper error handling and retry logic:

```typescript
// services/dub-service.ts
import { Dub } from "dub";

interface CreateLinkOptions {
  url: string;
  customSlug?: string;
  externalId?: string;
  utmParams?: {
    source?: string;
    medium?: string;
    campaign?: string;
    term?: string;
    content?: string;
  };
  expiresAt?: Date;
  password?: string;
  metadata?: {
    title?: string;
    description?: string;
  };
}

interface LinkResult {
  id: string;
  shortLink: string;
  qrCode: string;
  clicks: number;
  createdAt: string;
}

class DubService {
  private client: Dub;
  private maxRetries = 3;
  private baseDelay = 1000;

  constructor() {
    const token = process.env.DUB_API_KEY;
    if (!token) {
      throw new Error("DUB_API_KEY environment variable is required");
    }
    this.client = new Dub({ token });
  }

  async createLink(options: CreateLinkOptions): Promise<LinkResult> {
    return this.withRetry(async () => {
      const link = await this.client.links.create({
        url: options.url,
        key: options.customSlug,
        externalId: options.externalId,
        domain: process.env.DUB_CUSTOM_DOMAIN || "dub.sh",
        
        // UTM parameters for campaign tracking
        utm_source: options.utmParams?.source,
        utm_medium: options.utmParams?.medium,
        utm_campaign: options.utmParams?.campaign,
        utm_term: options.utmParams?.term,
        utm_content: options.utmParams?.content,
        
        // Link expiration
        expiresAt: options.expiresAt?.toISOString(),
        
        // Password protection
        password: options.password,
        
        // Custom metadata for link previews
        title: options.metadata?.title,
        description: options.metadata?.description,
        proxy: options.metadata ? true : false,
        
        // Enable conversion tracking
        trackConversion: true
      });

      return {
        id: link.id,
        shortLink: link.shortLink,
        qrCode: link.qrCode,
        clicks: link.clicks,
        createdAt: link.createdAt
      };
    });
  }

  async createReportLink(
    reportUrl: string,
    reportId: string,
    clientName: string
  ): Promise<LinkResult> {
    return this.createLink({
      url: reportUrl,
      customSlug: `report-${reportId}`,
      externalId: reportId,
      utmParams: {
        source: "consulting-report",
        medium: "link",
        campaign: clientName.toLowerCase().replace(/\s+/g, "-")
      },
      metadata: {
        title: `${clientName} Consulting Report`,
        description: "AI-powered analysis and recommendations"
      }
    });
  }

  async createBatchLinks(urls: string[]): Promise<LinkResult[]> {
    // Dub supports up to 100 links per batch
    const links = await this.client.links.createMany(
      urls.map(url => ({ url, trackConversion: true }))
    );
    
    return links.map(link => ({
      id: link.id,
      shortLink: link.shortLink,
      qrCode: link.qrCode,
      clicks: link.clicks,
      createdAt: link.createdAt
    }));
  }

  async getLink(linkId: string): Promise<LinkResult | null> {
    try {
      const link = await this.client.links.get({ linkId });
      return {
        id: link.id,
        shortLink: link.shortLink,
        qrCode: link.qrCode,
        clicks: link.clicks,
        createdAt: link.createdAt
      };
    } catch (error: any) {
      if (error.statusCode === 404) return null;
      throw error;
    }
  }

  async getLinkByExternalId(externalId: string): Promise<LinkResult | null> {
    try {
      const link = await this.client.links.get({ 
        externalId: `ext_${externalId}` 
      });
      return {
        id: link.id,
        shortLink: link.shortLink,
        qrCode: link.qrCode,
        clicks: link.clicks,
        createdAt: link.createdAt
      };
    } catch (error: any) {
      if (error.statusCode === 404) return null;
      throw error;
    }
  }

  async updateLink(linkId: string, url: string): Promise<LinkResult> {
    const link = await this.client.links.update({ linkId, url });
    return {
      id: link.id,
      shortLink: link.shortLink,
      qrCode: link.qrCode,
      clicks: link.clicks,
      createdAt: link.createdAt
    };
  }

  async deleteLink(linkId: string): Promise<boolean> {
    try {
      await this.client.links.delete({ linkId });
      return true;
    } catch {
      return false;
    }
  }

  private async withRetry<T>(
    operation: () => Promise<T>,
    attempt = 1
  ): Promise<T> {
    try {
      return await operation();
    } catch (error: any) {
      const isRateLimited = error.statusCode === 429;
      const isServerError = error.statusCode >= 500;
      
      if ((isRateLimited || isServerError) && attempt <= this.maxRetries) {
        const delay = this.baseDelay * Math.pow(2, attempt - 1);
        console.log(`Retry attempt ${attempt} after ${delay}ms`);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.withRetry(operation, attempt + 1);
      }
      
      throw error;
    }
  }
}

export const dubService = new DubService();
```

## Accessing analytics data

Analytics endpoints require a **Pro plan or higher**. The API provides rich data on clicks, geographic distribution, devices, referrers, and UTM parameter performance.

### Retrieving link analytics

```typescript
// services/dub-analytics.ts
import { Dub } from "dub";

interface AnalyticsParams {
  linkId?: string;
  externalId?: string;
  interval?: "24h" | "7d" | "30d" | "90d" | "1y" | "all";
  start?: string;
  end?: string;
}

interface ClickAnalytics {
  totalClicks: number;
  timeseries: { start: string; clicks: number }[];
  countries: { country: string; clicks: number }[];
  devices: { device: string; clicks: number }[];
  browsers: { browser: string; clicks: number }[];
  referrers: { referrer: string; clicks: number }[];
}

class DubAnalytics {
  private client: Dub;

  constructor() {
    this.client = new Dub({ token: process.env.DUB_API_KEY });
  }

  async getClickAnalytics(params: AnalyticsParams): Promise<ClickAnalytics> {
    const baseParams = {
      linkId: params.linkId,
      externalId: params.externalId ? `ext_${params.externalId}` : undefined,
      interval: params.interval || "30d",
      start: params.start,
      end: params.end
    };

    // Fetch multiple groupings in parallel
    const [count, timeseries, countries, devices, browsers, referrers] = 
      await Promise.all([
        this.client.analytics.retrieve({ ...baseParams, groupBy: "count" }),
        this.client.analytics.retrieve({ ...baseParams, groupBy: "timeseries" }),
        this.client.analytics.retrieve({ ...baseParams, groupBy: "countries" }),
        this.client.analytics.retrieve({ ...baseParams, groupBy: "devices" }),
        this.client.analytics.retrieve({ ...baseParams, groupBy: "browsers" }),
        this.client.analytics.retrieve({ ...baseParams, groupBy: "referrers" })
      ]);

    return {
      totalClicks: (count as any).clicks || 0,
      timeseries: timeseries as any[],
      countries: countries as any[],
      devices: devices as any[],
      browsers: browsers as any[],
      referrers: referrers as any[]
    };
  }

  async getTopPerformingLinks(
    interval: string = "30d"
  ): Promise<{ shortLink: string; clicks: number }[]> {
    const result = await this.client.analytics.retrieve({
      groupBy: "top_links",
      interval: interval as any
    });

    return (result as any[]).map(link => ({
      shortLink: link.shortLink,
      clicks: link.clicks
    }));
  }

  async getUTMBreakdown(linkId: string) {
    const [sources, mediums, campaigns] = await Promise.all([
      this.client.analytics.retrieve({ 
        linkId, 
        groupBy: "utm_sources", 
        interval: "30d" 
      }),
      this.client.analytics.retrieve({ 
        linkId, 
        groupBy: "utm_mediums", 
        interval: "30d" 
      }),
      this.client.analytics.retrieve({ 
        linkId, 
        groupBy: "utm_campaigns", 
        interval: "30d" 
      })
    ]);

    return { sources, mediums, campaigns };
  }
}

export const dubAnalytics = new DubAnalytics();
```

### Building an analytics dashboard endpoint

```typescript
// routes/analytics.ts
import express from "express";
import { dubAnalytics } from "../services/dub-analytics";

const router = express.Router();

router.get("/api/analytics/report/:reportId", async (req, res) => {
  try {
    const { reportId } = req.params;
    const { interval = "30d" } = req.query;

    const analytics = await dubAnalytics.getClickAnalytics({
      externalId: reportId,
      interval: interval as any
    });

    res.json({
      reportId,
      metrics: {
        totalViews: analytics.totalClicks,
        viewsOverTime: analytics.timeseries,
        topCountries: analytics.countries.slice(0, 5),
        deviceBreakdown: analytics.devices,
        browserBreakdown: analytics.browsers,
        trafficSources: analytics.referrers.slice(0, 10)
      }
    });
  } catch (error: any) {
    console.error("Analytics error:", error);
    res.status(500).json({ error: "Failed to retrieve analytics" });
  }
});

router.get("/api/analytics/dashboard", async (req, res) => {
  try {
    const topLinks = await dubAnalytics.getTopPerformingLinks("30d");
    res.json({ topLinks });
  } catch (error) {
    res.status(500).json({ error: "Failed to load dashboard" });
  }
});

export default router;
```

## Webhook setup for real-time click tracking

Webhooks enable instant notifications when links are clicked—essential for real-time dashboards and event-driven workflows. **Webhooks require a Business plan or higher.**

### Configuring webhooks in Dub.co

Navigate to **Webhooks** in your workspace settings and click "Create Webhook." Provide your Replit endpoint URL, select events to monitor (`link.clicked`, `link.created`, `lead.created`), and copy the generated signing secret to your Replit Secrets as `DUB_WEBHOOK_SECRET`.

Your webhook URL format depends on deployment status:
- **Development**: `https://your-app.username.replit.dev/api/webhooks/dub`
- **Production**: `https://your-app.replit.app/api/webhooks/dub`

Retrieve the correct URL programmatically:

```typescript
const getWebhookUrl = () => {
  const isDeployed = process.env.REPLIT_DEPLOYMENT === "1";
  const domain = isDeployed 
    ? process.env.REPLIT_DOMAINS?.split(",")[0]
    : process.env.REPLIT_DEV_DOMAIN;
  return `https://${domain}/api/webhooks/dub`;
};
```

### Implementing the webhook handler with signature verification

```typescript
// routes/webhooks.ts
import express from "express";
import crypto from "crypto";

const router = express.Router();

// Use raw body for signature verification
router.use("/api/webhooks/dub", express.raw({ type: "application/json" }));

interface DubWebhookPayload {
  id: string;
  event: "link.clicked" | "link.created" | "link.updated" | "link.deleted" | 
         "lead.created" | "sale.created";
  createdAt: string;
  data: {
    click?: {
      id: string;
      timestamp: string;
      url: string;
      country: string;
      city: string;
      device: string;
      browser: string;
      os: string;
      referer: string;
      bot: boolean;
    };
    link: {
      id: string;
      domain: string;
      key: string;
      shortLink: string;
      url: string;
      clicks: number;
      externalId?: string;
    };
  };
}

function verifySignature(rawBody: Buffer, signature: string): boolean {
  const secret = process.env.DUB_WEBHOOK_SECRET;
  if (!secret) {
    console.error("DUB_WEBHOOK_SECRET not configured");
    return false;
  }

  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(rawBody)
    .digest("hex");

  try {
    return crypto.timingSafeEquals(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  } catch {
    return false;
  }
}

router.post("/api/webhooks/dub", async (req, res) => {
  const signature = req.headers["dub-signature"] as string;

  // Verify webhook authenticity
  if (!verifySignature(req.body, signature)) {
    console.warn("Invalid webhook signature");
    return res.status(401).json({ error: "Invalid signature" });
  }

  // Respond immediately to prevent timeout
  res.status(200).json({ received: true });

  // Parse and process payload asynchronously
  const payload: DubWebhookPayload = JSON.parse(req.body.toString());
  
  console.log(`Webhook received: ${payload.event}`);
  
  try {
    switch (payload.event) {
      case "link.clicked":
        await handleLinkClick(payload);
        break;
      case "link.created":
        console.log(`New link created: ${payload.data.link.shortLink}`);
        break;
      case "lead.created":
        await handleLeadConversion(payload);
        break;
      case "sale.created":
        await handleSaleConversion(payload);
        break;
    }
  } catch (error) {
    console.error("Webhook processing error:", error);
  }
});

async function handleLinkClick(payload: DubWebhookPayload) {
  const { click, link } = payload.data;
  if (!click) return;

  // Log click event for analytics
  console.log({
    event: "report_viewed",
    reportId: link.externalId,
    timestamp: click.timestamp,
    location: `${click.city}, ${click.country}`,
    device: click.device,
    browser: click.browser,
    source: click.referer
  });

  // Store in database, send notifications, update dashboards, etc.
}

async function handleLeadConversion(payload: DubWebhookPayload) {
  console.log(`Lead conversion for link: ${payload.data.link.shortLink}`);
}

async function handleSaleConversion(payload: DubWebhookPayload) {
  console.log(`Sale conversion for link: ${payload.data.link.shortLink}`);
}

export default router;
```

## Complete Express application setup

Assemble everything into a production-ready application:

```typescript
// server.ts
import express from "express";
import cors from "cors";
import { dubService } from "./services/dub-service";
import analyticsRouter from "./routes/analytics";
import webhooksRouter from "./routes/webhooks";

const app = express();

// Middleware (webhook route uses raw body parser, applied in route file)
app.use(cors());
app.use(express.json());

// Mount routes
app.use(analyticsRouter);
app.use(webhooksRouter);

// Create short link for a consulting report
app.post("/api/reports/:reportId/share", async (req, res) => {
  try {
    const { reportId } = req.params;
    const { clientName, reportUrl, expiresInDays } = req.body;

    const link = await dubService.createReportLink(
      reportUrl,
      reportId,
      clientName
    );

    res.json({
      shortUrl: link.shortLink,
      qrCode: link.qrCode,
      trackingId: link.id,
      expiresAt: expiresInDays 
        ? new Date(Date.now() + expiresInDays * 86400000) 
        : null
    });
  } catch (error: any) {
    console.error("Link creation error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Retrieve link status and basic metrics
app.get("/api/reports/:reportId/link", async (req, res) => {
  try {
    const link = await dubService.getLinkByExternalId(req.params.reportId);
    if (!link) {
      return res.status(404).json({ error: "Link not found" });
    }
    res.json(link);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get("/health", (req, res) => {
  const domains = process.env.REPLIT_DOMAINS;
  const devDomain = process.env.REPLIT_DEV_DOMAIN;
  
  res.json({
    status: "healthy",
    environment: process.env.REPLIT_DEPLOYMENT === "1" ? "production" : "development",
    webhookUrl: `https://${domains?.split(",")[0] || devDomain}/api/webhooks/dub`
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## Rate limits and optimization strategies

Dub enforces rate limits that vary by plan: **Free** allows 60 requests/minute, **Pro** provides 600/minute with 2 analytics requests/second, **Business** offers 1,200/minute with 4 analytics requests/second. The API returns `X-RateLimit-Remaining` and `Retry-After` headers.

**Best practices for staying within limits:**

- Use bulk endpoints (`POST /links/bulk`) for creating multiple links—up to **100 per request**
- Fetch workspace-level analytics instead of per-link queries when possible
- Implement exponential backoff retry logic (included in the service module above)
- Leverage webhooks for real-time data instead of polling the analytics API
- Cache frequently accessed link data to reduce API calls

## Replit deployment considerations

Deploy your application using **Autoscale Deployment** (the recommended type for Agent 3 full-stack apps). Autoscale deployments scale from zero instances during idle periods to multiple instances under load, with pay-per-use pricing.

**Key deployment notes:**

- **SSL is automatic**—all `.replit.app` URLs are HTTPS-enabled with no certificate management required
- **Secrets transfer automatically** to production deployments
- **Cold starts** may add ~500ms latency on first request after idle; for always-on webhook handling, consider Reserved VM deployment
- **Update webhook URLs** in Dub.co dashboard after deploying, switching from `.replit.dev` to `.replit.app`

For consulting tools where reports may receive irregular traffic, Autoscale is ideal—you pay nothing when clients aren't viewing reports, but the system handles traffic spikes when reports are actively shared.

## Conclusion

This implementation provides professional URL shortening with comprehensive analytics for AI consulting reports. The Dub.co TypeScript SDK handles authentication and request formatting, while the service module adds retry logic and a clean interface for your application. Webhooks enable real-time tracking dashboards, and the analytics API surfaces geographic and device insights about report engagement.

Key integration points to remember: store your API key in Replit Secrets as `DUB_API_KEY`, use `externalId` to link shortened URLs back to your report database, and configure webhooks with signature verification for security. The Pro plan unlocks analytics access, while Business or higher enables webhook functionality—both essential features for a professional consulting tool that tracks client engagement with deliverables.